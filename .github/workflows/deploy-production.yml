name: Deploy to Production VPS

on:
  push:
    branches:
      - main
    paths:
      - 'deploy-backend/**'
      - '.github/workflows/deploy-production.yml'
  workflow_dispatch:

env:
  VPS_HOST: ${{ secrets.VPS_HOST }}
  VPS_USER: ${{ secrets.VPS_USER }}
  VPS_PATH: /root/deploy-backend

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: deploy-backend/package-lock.json

      - name: Install dependencies
        working-directory: deploy-backend
        run: npm ci

      - name: Run linting
        working-directory: deploy-backend
        run: npm run lint || echo "::warning::Linting issues found"

      - name: Run type check
        working-directory: deploy-backend
        run: npx tsc --noEmit || echo "::warning::Type check issues found"

      - name: Run tests
        working-directory: deploy-backend
        run: npm run test -- --passWithNoTests
        env:
          NODE_ENV: test

  deploy:
    name: Deploy to Production VPS
    runs-on: ubuntu-latest
    needs: test
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH key
        env:
          SSH_PRIVATE_KEY: ${{ secrets.VPS_SSH_KEY }}
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # ssh-keyscan com timeout e fallback
          ssh-keyscan -t ed25519,rsa -T 10 -H "$VPS_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

          # SSH config global para usar a key e aceitar hosts novos
          cat >> ~/.ssh/config << SSHEOF
          Host *
            StrictHostKeyChecking accept-new
            IdentityFile ~/.ssh/deploy_key
            ConnectTimeout 10
            ServerAliveInterval 30
            ServerAliveCountMax 3
          SSHEOF
          chmod 600 ~/.ssh/config

      - name: Test SSH connection
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo 'SSH OK'"

      - name: Create backup and save current image
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'EOF'
            set -e
            cd /root/deploy-backend
            mkdir -p backups

            # Backup do banco de dados
            if docker ps | grep -q crm-postgres; then
              echo "Creating database backup..."
              docker exec crm-postgres pg_dump -U crm_user crm_whatsapp_saas > "backups/pre-deploy-$(date +%Y%m%d-%H%M%S).sql" 2>/dev/null || echo "Warning: Database backup failed"
            fi

            # Log current deploy state
            CURRENT_COLOR=$(cat .deploy-color 2>/dev/null || echo "none")
            echo "Current active color: $CURRENT_COLOR"

            # Limpar backups antigos (manter ultimos 5)
            ls -t backups/*.sql 2>/dev/null | tail -n +6 | xargs -r rm -f || true
          EOF

      - name: Sync files to VPS
        run: |
          rsync -avz --delete \
            --exclude 'node_modules' \
            --exclude 'dist' \
            --exclude '.env' \
            --exclude '.env.*' \
            --exclude 'coverage' \
            --exclude 'backups' \
            --exclude 'certbot' \
            --exclude '*.test.ts' \
            --exclude 'src/test' \
            --exclude 'logs' \
            --exclude 'uploads' \
            --exclude '.deploy-color' \
            --exclude 'nginx/conf.d/upstream-backend.conf' \
            deploy-backend/ \
            ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.VPS_PATH }}/

      - name: Run manual database migrations
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'EOF'
            set -e
            cd /root/deploy-backend

            # Criar tabela de controle de migrations (se nao existir)
            docker exec crm-postgres psql -U ${POSTGRES_USER:-crm_user} -d ${POSTGRES_DB:-crm_whatsapp_saas} -c "
              CREATE TABLE IF NOT EXISTS _migrations_manual (
                filename TEXT PRIMARY KEY,
                applied_at TIMESTAMPTZ DEFAULT NOW()
              );
            "

            # Rodar cada migration manual que ainda nao foi aplicada
            for f in prisma/migrations-manual/*.sql; do
              if [ -f "$f" ]; then
                BASENAME=$(basename "$f")
                ALREADY=$(docker exec crm-postgres psql -U ${POSTGRES_USER:-crm_user} -d ${POSTGRES_DB:-crm_whatsapp_saas} -tAc "SELECT 1 FROM _migrations_manual WHERE filename='$BASENAME'" 2>/dev/null || echo "")
                if [ "$ALREADY" != "1" ]; then
                  echo "Applying migration: $BASENAME"
                  docker exec -i crm-postgres psql -U ${POSTGRES_USER:-crm_user} -d ${POSTGRES_DB:-crm_whatsapp_saas} < "$f"
                  docker exec crm-postgres psql -U ${POSTGRES_USER:-crm_user} -d ${POSTGRES_DB:-crm_whatsapp_saas} -c "INSERT INTO _migrations_manual (filename) VALUES ('$BASENAME')"
                  echo "Migration $BASENAME applied successfully"
                else
                  echo "Migration $BASENAME already applied, skipping"
                fi
              fi
            done

            echo "All manual migrations up to date"
          EOF

      - name: Zero-downtime deploy (blue/green)
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'EOF'
            set -e
            cd /root/deploy-backend
            chmod +x scripts/zero-downtime-deploy.sh
            bash scripts/zero-downtime-deploy.sh
          EOF

      - name: Health check with rollback
        run: |
          for i in $(seq 1 20); do
            RESPONSE=$(curl -s -o /dev/null -w '%{http_code}' https://api.botreserva.com.br/api/health || echo "000")
            if [ "$RESPONSE" = "200" ]; then
              echo "External health check OK!"
              curl -s https://api.botreserva.com.br/api/health | jq '.' || true
              exit 0
            fi
            echo "Attempt $i/20 - Status: $RESPONSE"
            sleep 3
          done

          echo "External health check failed! Rolling back..."
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'EOF'
            cd /root/deploy-backend
            TARGET=$(cat .deploy-color 2>/dev/null || echo "blue")
            PREVIOUS=$([ "$TARGET" = "blue" ] && echo "green" || echo "blue")

            echo "Current: $TARGET, Rolling back to: $PREVIOUS"
            echo "Container logs:"
            docker logs "crm-backend-$TARGET" --tail=30 2>/dev/null || true

            # Verificar se container anterior existe
            if docker ps -a --format '{{.Names}}' | grep -q "crm-backend-$PREVIOUS"; then
              echo "Starting previous container: crm-backend-$PREVIOUS"
              docker start "crm-backend-$PREVIOUS" 2>/dev/null || true
              sleep 10

              # Switch nginx back
              cat > nginx/conf.d/upstream-backend.conf << NGINXEOF
          # Managed by zero-downtime-deploy.sh - ROLLBACK
          upstream backend {
              server crm-backend-$PREVIOUS:3001;
              keepalive 32;
              keepalive_timeout 60s;
              keepalive_requests 100;
          }
          NGINXEOF
              docker exec crm-nginx nginx -t && docker exec crm-nginx nginx -s reload

              # Stop failed container
              docker compose -f docker-compose.production.yml --profile $TARGET stop backend-$TARGET 2>/dev/null || true
              docker compose -f docker-compose.production.yml --profile $TARGET rm -f backend-$TARGET 2>/dev/null || true

              echo "$PREVIOUS" > .deploy-color
              echo "Rolled back to $PREVIOUS"
            else
              echo "No previous container available for rollback!"
            fi
          EOF
          exit 1

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          rm -f ~/.ssh/config
