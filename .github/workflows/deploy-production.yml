name: Deploy to Production VPS

on:
  push:
    branches:
      - master
    paths:
      - 'deploy-backend/**'
      - '.github/workflows/deploy-production.yml'
  workflow_dispatch: # Allow manual trigger

env:
  VPS_HOST: ${{ secrets.VPS_HOST }}
  VPS_USER: ${{ secrets.VPS_USER }}
  VPS_PATH: ${{ secrets.VPS_PATH }}
  DEPLOY_TIMEOUT: 600 # 10 minutes
  HEALTH_CHECK_URL: https://api.botreserva.com.br/api/health

jobs:
  deploy:
    name: Deploy Backend to VPS
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      # ============================================
      # 1. CHECKOUT CODE
      # ============================================
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2 # Fetch last 2 commits for rollback

      # ============================================
      # 2. SETUP SSH
      # ============================================
      - name: Setup SSH key
        run: |
          echo "::group::Configure SSH"
          mkdir -p ~/.ssh

          # Handle both base64-encoded and raw SSH keys
          if echo "${{ secrets.VPS_SSH_KEY }}" | grep -q "BEGIN OPENSSH PRIVATE KEY"; then
            # Raw key format
            echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          else
            # Assume base64-encoded
            echo "${{ secrets.VPS_SSH_KEY }}" | base64 -d > ~/.ssh/deploy_key
          fi

          chmod 600 ~/.ssh/deploy_key

          # Add VPS to known_hosts
          ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts

          # Verify key format
          if ! ssh-keygen -l -f ~/.ssh/deploy_key > /dev/null 2>&1; then
            echo "::error::Invalid SSH key format. Please check VPS_SSH_KEY secret."
            exit 1
          fi

          # Test SSH connection
          ssh -i ~/.ssh/deploy_key -o ConnectTimeout=10 ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo 'SSH connection successful'"
          echo "::endgroup::"

      # ============================================
      # 3. PRE-DEPLOYMENT CHECKS
      # ============================================
      - name: Pre-deployment checks
        run: |
          echo "::group::Pre-deployment checks"

          # Check if VPS is reachable (informative only - many VPS block ICMP)
          echo "Checking VPS connectivity via ping (informative only)..."
          if ping -c 3 ${{ env.VPS_HOST }} 2>&1; then
            echo "✓ VPS responds to ICMP ping"
          else
            echo "::warning::VPS does not respond to ping (ICMP may be blocked by firewall)"
            echo "This is normal for security-hardened servers. SSH connectivity will be verified next."
          fi

          # Verify SSH connectivity (critical check)
          echo "✓ Verifying SSH connectivity (critical)..."
          if ! ssh -i ~/.ssh/deploy_key -o ConnectTimeout=10 ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo 'SSH connection verified' && uptime"; then
            echo "::error::SSH connection failed. Cannot proceed with deployment."
            exit 1
          fi

          # Check disk space on VPS
          echo "✓ Checking VPS disk space..."
          DISK_USAGE=$(ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "df -h ${{ env.VPS_PATH }} | tail -1 | awk '{print \$5}' | sed 's/%//'")
          echo "Disk usage: ${DISK_USAGE}%"

          if [ "$DISK_USAGE" -gt 90 ]; then
            echo "::error::Disk usage is above 90%. Aborting deployment."
            exit 1
          fi

          # Check if Docker is running
          echo "✓ Checking Docker status..."
          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "docker info > /dev/null 2>&1 || (echo '::error::Docker is not running' && exit 1)"

          echo "::endgroup::"

      # ============================================
      # 4. CREATE BACKUP
      # ============================================
      - name: Create backup before deployment
        run: |
          echo "::group::Create backup"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'BACKUP_SCRIPT'
            set -e
            cd ${{ env.VPS_PATH }}

            # Create backup directory
            BACKUP_DIR="backups/pre-deploy-$(date +%Y%m%d-%H%M%S)"
            mkdir -p "$BACKUP_DIR"

            echo "Creating backup in $BACKUP_DIR..."

            # Backup current Docker image (for quick rollback)
            if docker images | grep -q "deploy-backend[_-]backend"; then
              echo "Tagging current Docker image for backup..."
              docker tag deploy-backend_backend:latest deploy-backend_backend:backup-$(date +%Y%m%d-%H%M%S) || true
              echo "✓ Docker image tagged for backup"
            fi

            # Backup database (optional - if DB is small)
            if docker ps | grep -q crm-postgres; then
              echo "Creating database backup..."
              docker exec crm-postgres pg_dump -U crm_user crm_whatsapp_saas > "$BACKUP_DIR/database.sql" 2>/dev/null || true
              echo "✓ Database backed up"
            fi

            # Keep only last 5 backup directories
            cd backups
            ls -td pre-deploy-* 2>/dev/null | tail -n +6 | xargs -r rm -rf || true

            # Keep only last 3 Docker backup images
            docker images --format "{{.Repository}}:{{.Tag}}" | grep "deploy-backend_backend:backup-" | tail -n +4 | xargs -r docker rmi || true

            echo "✓ Backup completed: $BACKUP_DIR"
          BACKUP_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 5. SYNC FILES TO VPS
      # ============================================
      - name: Sync files to VPS
        run: |
          echo "::group::Sync files via rsync"

          # Sync deploy-backend/ to VPS
          # Note: We sync source files because Docker will build inside the container
          rsync -avz --delete \
            --exclude 'node_modules' \
            --exclude 'dist' \
            --exclude '.env' \
            --exclude '.env.production' \
            --exclude 'coverage' \
            --exclude 'backups' \
            --exclude 'certbot' \
            --exclude 'test-*.ts' \
            -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            deploy-backend/ \
            ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.VPS_PATH }}/

          echo "✓ Files synced successfully"
          echo "::endgroup::"

      # ============================================
      # 6. BUILD DOCKER IMAGE
      # ============================================
      - name: Build Docker image
        run: |
          echo "::group::Build Docker image"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'BUILD_SCRIPT'
            set -e
            cd ${{ env.VPS_PATH }}

            echo "Building backend Docker image..."
            docker-compose -f docker-compose.production.yml build backend

            echo "✓ Docker image built successfully"
          BUILD_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 7. START BACKEND CONTAINER
      # ============================================
      - name: Start backend container
        run: |
          echo "::group::Start backend container"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'START_SCRIPT'
            set -e
            cd ${{ env.VPS_PATH }}

            echo "Starting backend container..."
            docker-compose -f docker-compose.production.yml up -d --no-deps --force-recreate backend

            echo "✓ Backend container started"

            # Wait for backend to be healthy
            echo "Waiting for backend container to be healthy..."
            timeout 60 bash -c 'until docker inspect --format="{{.State.Health.Status}}" crm-backend | grep -q "healthy"; do echo "Waiting..."; sleep 3; done' || {
              echo "::warning::Container health check timeout (this is normal if health endpoint takes time to start)"
            }

            # Show container status
            echo ""
            echo "Container status:"
            docker-compose -f docker-compose.production.yml ps backend
          START_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 8. RUN DATABASE MIGRATIONS
      # ============================================
      - name: Run database migrations
        run: |
          echo "::group::Run database migrations"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'MIGRATE_SCRIPT'
            set -e
            cd ${{ env.VPS_PATH }}

            # Wait for postgres to be ready
            echo "Waiting for PostgreSQL..."
            timeout 30 bash -c 'until docker exec crm-postgres pg_isready -U crm_user 2>/dev/null; do echo "Waiting for PostgreSQL..."; sleep 2; done' || {
              echo "::warning::PostgreSQL readiness check timeout"
            }

            # Run migrations inside the backend container
            echo "Running Prisma migrations inside backend container..."
            docker-compose -f docker-compose.production.yml exec -T backend npx prisma migrate deploy || {
              echo "::error::Failed to run migrations"
              echo "Container logs:"
              docker-compose -f docker-compose.production.yml logs --tail=30 backend
              exit 1
            }

            echo "✓ Migrations completed successfully"
          MIGRATE_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 9. HEALTH CHECK
      # ============================================
      - name: Health check
        run: |
          echo "::group::Health check"

          MAX_RETRIES=30
          RETRY_INTERVAL=5

          echo "Waiting for application to be healthy..."
          echo "Health check URL: ${{ env.HEALTH_CHECK_URL }}"

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES..."

            if curl -f -s -o /dev/null -w "%{http_code}" ${{ env.HEALTH_CHECK_URL }} | grep -q "200"; then
              echo "✓ Application is healthy!"

              # Get detailed health info
              echo ""
              echo "Health details:"
              curl -s ${{ env.HEALTH_CHECK_URL }} | jq '.' || curl -s ${{ env.HEALTH_CHECK_URL }}

              exit 0
            fi

            if [ $i -lt $MAX_RETRIES ]; then
              echo "Not healthy yet, waiting ${RETRY_INTERVAL}s..."
              sleep $RETRY_INTERVAL
            fi
          done

          echo "::error::Health check failed after $MAX_RETRIES attempts"

          # Show container logs for debugging
          echo ""
          echo "Backend logs (last 50 lines):"
          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} \
            "cd ${{ env.VPS_PATH }} && docker-compose -f docker-compose.production.yml logs --tail=50 backend"

          exit 1

          echo "::endgroup::"

      # ============================================
      # 10. POST-DEPLOYMENT VERIFICATION
      # ============================================
      - name: Post-deployment verification
        if: success()
        run: |
          echo "::group::Post-deployment verification"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'VERIFY_SCRIPT'
            cd ${{ env.VPS_PATH }}

            echo "Checking all containers..."
            docker-compose -f docker-compose.production.yml ps

            echo ""
            echo "Checking container health..."
            docker ps --filter "name=crm-" --format "table {{.Names}}\t{{.Status}}"

            echo ""
            echo "Disk usage:"
            df -h ${{ env.VPS_PATH }}
          VERIFY_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 11. CLEANUP
      # ============================================
      - name: Cleanup SSH keys
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key

      # ============================================
      # 12. SEND NOTIFICATION (Optional)
      # ============================================
      - name: Deployment summary
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✓ Deployment successful!"
            echo "URL: ${{ env.HEALTH_CHECK_URL }}"
          else
            echo "✗ Deployment failed!"
            echo "Check logs above for details"
          fi

  # ============================================
  # ROLLBACK JOB (Manual trigger only)
  # ============================================
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'workflow_dispatch'
    needs: deploy

    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh

          # Handle both base64-encoded and raw SSH keys
          if echo "${{ secrets.VPS_SSH_KEY }}" | grep -q "BEGIN OPENSSH PRIVATE KEY"; then
            echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          else
            echo "${{ secrets.VPS_SSH_KEY }}" | base64 -d > ~/.ssh/deploy_key
          fi

          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Rollback to previous backup
        run: |
          echo "::group::Rollback deployment"

          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ROLLBACK_SCRIPT'
            set -e
            cd ${{ secrets.VPS_PATH }}

            # Find most recent backup Docker image
            LATEST_BACKUP_IMAGE=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "deploy-backend_backend:backup-" | head -1)

            if [ -z "$LATEST_BACKUP_IMAGE" ]; then
              echo "::error::No Docker backup image found for rollback"
              exit 1
            fi

            echo "Rolling back to Docker image: $LATEST_BACKUP_IMAGE"

            # Tag backup image as latest
            docker tag "$LATEST_BACKUP_IMAGE" deploy-backend_backend:latest

            # Restart backend container with the backup image
            docker-compose -f docker-compose.production.yml up -d --no-deps --force-recreate backend

            echo "✓ Rollback completed - backend running with backup image"

            # Show container status
            echo ""
            echo "Container status:"
            docker-compose -f docker-compose.production.yml ps backend
          ROLLBACK_SCRIPT

          echo "::endgroup::"

      - name: Cleanup
        if: always()
        run: rm -f ~/.ssh/deploy_key
