name: Deploy to Production VPS

on:
  push:
    branches:
      - master
    paths:
      - 'deploy-backend/**'
      - '.github/workflows/deploy-production.yml'
  workflow_dispatch: # Allow manual trigger

env:
  VPS_HOST: ${{ secrets.VPS_HOST }}
  VPS_USER: ${{ secrets.VPS_USER }}
  VPS_PATH: ${{ secrets.VPS_PATH }}
  DEPLOY_TIMEOUT: 600
  HEALTH_CHECK_URL: https://api.botreserva.com.br/api/health

jobs:
  # ============================================
  # TEST JOB - Run tests before deployment
  # ============================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: deploy-backend/package-lock.json

      - name: Install dependencies
        working-directory: deploy-backend
        run: npm ci

      - name: Run linting
        working-directory: deploy-backend
        run: npm run lint || echo "::warning::Linting issues found"

      - name: Run type check
        working-directory: deploy-backend
        run: npx tsc --noEmit || echo "::warning::Type check issues found"

      - name: Run tests
        working-directory: deploy-backend
        run: npm run test -- --coverage --passWithNoTests
        env:
          NODE_ENV: test

      - name: Check coverage threshold
        working-directory: deploy-backend
        run: |
          # Verify minimum coverage (will fail build if below threshold)
          npm run test -- --coverage --coverageThreshold='{"global":{"lines":40,"branches":30}}'
        continue-on-error: true

      - name: Upload coverage report
        uses: codecov/codecov-action@v3
        with:
          directory: deploy-backend/coverage
          fail_ci_if_error: false
        continue-on-error: true

  # ============================================
  # SECURITY CHECK JOB
  # ============================================
  security:
    name: Security Checks
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: deploy-backend/package-lock.json

      - name: Install dependencies
        working-directory: deploy-backend
        run: npm ci

      - name: Run npm audit
        working-directory: deploy-backend
        run: npm audit --audit-level=high || echo "::warning::Security vulnerabilities found"
        continue-on-error: true

  # ============================================
  # DEPLOY JOB - Deploy to production
  # ============================================
  deploy:
    name: Deploy Backend to VPS
    runs-on: ubuntu-latest
    needs: [test, security]
    timeout-minutes: 15

    steps:
      # ============================================
      # 1. CHECKOUT CODE
      # ============================================
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      # ============================================
      # 2. SETUP SSH
      # ============================================
      - name: Setup SSH key
        run: |
          echo "::group::Configure SSH"
          mkdir -p ~/.ssh

          # Handle both base64-encoded and raw SSH keys
          if echo "${{ secrets.VPS_SSH_KEY }}" | grep -q "BEGIN OPENSSH PRIVATE KEY"; then
            echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          else
            echo "${{ secrets.VPS_SSH_KEY }}" | base64 -d > ~/.ssh/deploy_key
          fi

          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts

          # Verify key format
          if ! ssh-keygen -l -f ~/.ssh/deploy_key > /dev/null 2>&1; then
            echo "::error::Invalid SSH key format."
            exit 1
          fi

          # Test SSH connection
          ssh -i ~/.ssh/deploy_key -o ConnectTimeout=10 ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo 'SSH connection successful'"
          echo "::endgroup::"

      # ============================================
      # 3. PRE-DEPLOYMENT CHECKS
      # ============================================
      - name: Pre-deployment checks
        run: |
          echo "::group::Pre-deployment checks"

          # Verify SSH connectivity
          echo "✓ Verifying SSH connectivity..."
          ssh -i ~/.ssh/deploy_key -o ConnectTimeout=10 ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo 'SSH verified' && uptime"

          # Check disk space on VPS
          echo "✓ Checking VPS disk space..."
          DISK_USAGE=$(ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "df -h ${{ env.VPS_PATH }} | tail -1 | awk '{print \$5}' | sed 's/%//'")
          echo "Disk usage: ${DISK_USAGE}%"

          if [ "$DISK_USAGE" -gt 90 ]; then
            echo "::error::Disk usage is above 90%. Aborting deployment."
            exit 1
          fi

          # Check if Docker is running
          echo "✓ Checking Docker status..."
          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "docker info > /dev/null 2>&1"

          echo "::endgroup::"

      # ============================================
      # 4. CREATE BACKUP
      # ============================================
      - name: Create backup before deployment
        run: |
          echo "::group::Create backup"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'BACKUP_SCRIPT'
            set -e
            cd ${{ env.VPS_PATH }}

            # Create backup directory
            BACKUP_DIR="backups/pre-deploy-$(date +%Y%m%d-%H%M%S)"
            mkdir -p "$BACKUP_DIR"

            echo "Creating backup in $BACKUP_DIR..."

            # Backup current Docker image
            if docker images | grep -q "deploy-backend[_-]backend"; then
              echo "Tagging current Docker image for backup..."
              docker tag deploy-backend-backend:latest deploy-backend-backend:backup-$(date +%Y%m%d-%H%M%S) 2>/dev/null || \
              docker tag deploy-backend_backend:latest deploy-backend_backend:backup-$(date +%Y%m%d-%H%M%S) 2>/dev/null || true
              echo "✓ Docker image tagged for backup"
            fi

            # Backup database
            if docker ps | grep -q crm-postgres; then
              echo "Creating database backup..."
              docker exec crm-postgres pg_dump -U crm_user crm_whatsapp_saas > "$BACKUP_DIR/database.sql" 2>/dev/null || true
              echo "✓ Database backed up"
            fi

            # Keep only last 5 backup directories
            cd backups
            ls -td pre-deploy-* 2>/dev/null | tail -n +6 | xargs -r rm -rf || true

            # Keep only last 3 Docker backup images
            docker images --format "{{.Repository}}:{{.Tag}}" | grep "backup-" | tail -n +4 | xargs -r docker rmi 2>/dev/null || true

            echo "✓ Backup completed: $BACKUP_DIR"
          BACKUP_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 5. SYNC FILES TO VPS (ONLY deploy-backend)
      # ============================================
      - name: Sync files to VPS
        run: |
          echo "::group::Sync files via rsync"

          # Sync ONLY deploy-backend/ to VPS (not the entire repository)
          rsync -avz --delete \
            --exclude 'node_modules' \
            --exclude 'dist' \
            --exclude '.env' \
            --exclude '.env.production' \
            --exclude 'coverage' \
            --exclude 'backups' \
            --exclude 'certbot' \
            --exclude '*.test.ts' \
            --exclude 'test-*.ts' \
            --exclude 'jest.config.js' \
            --exclude 'jest.setup.ts' \
            --exclude 'src/test' \
            -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            deploy-backend/ \
            ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.VPS_PATH }}/

          echo "✓ Files synced successfully (only deploy-backend)"
          echo "::endgroup::"

      # ============================================
      # 6. BUILD DOCKER IMAGE
      # ============================================
      - name: Build Docker image
        run: |
          echo "::group::Build Docker image"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'BUILD_SCRIPT'
            set -e
            cd ${{ env.VPS_PATH }}

            echo "Building backend Docker image..."
            docker compose -f docker-compose.production.yml build backend

            echo "✓ Docker image built successfully"
          BUILD_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 7. START BACKEND CONTAINER
      # ============================================
      - name: Start backend container
        run: |
          echo "::group::Start backend container"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'START_SCRIPT'
            set -e
            cd ${{ env.VPS_PATH }}

            echo "Starting backend container..."
            docker compose -f docker-compose.production.yml up -d --no-deps --force-recreate backend

            echo "✓ Backend container started"

            # Wait for backend to be healthy
            echo "Waiting for backend container to be healthy..."
            timeout 90 bash -c 'until docker inspect --format="{{.State.Health.Status}}" crm-backend | grep -q "healthy"; do echo "Waiting..."; sleep 5; done' || {
              echo "::warning::Container health check timeout"
            }

            # Show container status
            echo ""
            echo "Container status:"
            docker compose -f docker-compose.production.yml ps backend
          START_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 8. RUN DATABASE MIGRATIONS
      # ============================================
      - name: Run database migrations
        run: |
          echo "::group::Run database migrations"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'MIGRATE_SCRIPT'
            set -e
            cd ${{ env.VPS_PATH }}

            # Wait for postgres to be ready
            echo "Waiting for PostgreSQL..."
            timeout 30 bash -c 'until docker exec crm-postgres pg_isready -U crm_user 2>/dev/null; do echo "Waiting..."; sleep 2; done' || true

            # Run migrations inside the backend container
            echo "Running Prisma migrations..."
            docker compose -f docker-compose.production.yml exec -T backend npx prisma migrate deploy || {
              echo "::error::Failed to run migrations"
              docker compose -f docker-compose.production.yml logs --tail=30 backend
              exit 1
            }

            echo "✓ Migrations completed successfully"
          MIGRATE_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 9. HEALTH CHECK
      # ============================================
      - name: Health check
        run: |
          echo "::group::Health check"

          MAX_RETRIES=30
          RETRY_INTERVAL=5

          echo "Waiting for application to be healthy..."
          echo "Health check URL: ${{ env.HEALTH_CHECK_URL }}"

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES..."

            if curl -f -s -o /dev/null -w "%{http_code}" ${{ env.HEALTH_CHECK_URL }} | grep -q "200"; then
              echo "✓ Application is healthy!"

              # Get detailed health info
              echo ""
              echo "Health details:"
              curl -s ${{ env.HEALTH_CHECK_URL }} | jq '.' || curl -s ${{ env.HEALTH_CHECK_URL }}

              exit 0
            fi

            if [ $i -lt $MAX_RETRIES ]; then
              echo "Not healthy yet, waiting ${RETRY_INTERVAL}s..."
              sleep $RETRY_INTERVAL
            fi
          done

          echo "::error::Health check failed after $MAX_RETRIES attempts"

          # Show container logs for debugging
          echo ""
          echo "Backend logs (last 50 lines):"
          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} \
            "cd ${{ env.VPS_PATH }} && docker compose -f docker-compose.production.yml logs --tail=50 backend"

          exit 1

      # ============================================
      # 10. POST-DEPLOYMENT VERIFICATION
      # ============================================
      - name: Post-deployment verification
        if: success()
        run: |
          echo "::group::Post-deployment verification"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'VERIFY_SCRIPT'
            cd ${{ env.VPS_PATH }}

            echo "Checking all containers..."
            docker compose -f docker-compose.production.yml ps

            echo ""
            echo "Checking container health..."
            docker ps --filter "name=crm-" --format "table {{.Names}}\t{{.Status}}"

            echo ""
            echo "Disk usage:"
            df -h ${{ env.VPS_PATH }}
          VERIFY_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 11. CLEANUP
      # ============================================
      - name: Cleanup SSH keys
        if: always()
        run: rm -f ~/.ssh/deploy_key

      # ============================================
      # 12. DEPLOYMENT SUMMARY
      # ============================================
      - name: Deployment summary
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✓ Production deployment successful!"
            echo "URL: ${{ env.HEALTH_CHECK_URL }}"
          else
            echo "✗ Deployment failed!"
            echo "Check logs above for details"
          fi

  # ============================================
  # ROLLBACK JOB (Manual trigger only)
  # ============================================
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'workflow_dispatch'
    needs: deploy

    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh

          if echo "${{ secrets.VPS_SSH_KEY }}" | grep -q "BEGIN OPENSSH PRIVATE KEY"; then
            echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          else
            echo "${{ secrets.VPS_SSH_KEY }}" | base64 -d > ~/.ssh/deploy_key
          fi

          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Rollback to previous backup
        run: |
          echo "::group::Rollback deployment"

          ssh -i ~/.ssh/deploy_key ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ROLLBACK_SCRIPT'
            set -e
            cd ${{ secrets.VPS_PATH }}

            # Find most recent backup Docker image
            LATEST_BACKUP_IMAGE=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "backend:backup-" | head -1)

            if [ -z "$LATEST_BACKUP_IMAGE" ]; then
              echo "::error::No Docker backup image found"
              exit 1
            fi

            echo "Rolling back to: $LATEST_BACKUP_IMAGE"

            # Tag backup as latest
            docker tag "$LATEST_BACKUP_IMAGE" deploy-backend-backend:latest 2>/dev/null || \
            docker tag "$LATEST_BACKUP_IMAGE" deploy-backend_backend:latest 2>/dev/null

            # Restart with backup
            docker compose -f docker-compose.production.yml up -d --no-deps --force-recreate backend

            echo "✓ Rollback completed"
            docker compose -f docker-compose.production.yml ps backend
          ROLLBACK_SCRIPT

          echo "::endgroup::"

      - name: Cleanup
        if: always()
        run: rm -f ~/.ssh/deploy_key
