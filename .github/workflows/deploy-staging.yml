name: Deploy to Staging VPS

on:
  push:
    branches:
      - develop
    paths:
      - 'deploy-backend/**'
      - '.github/workflows/deploy-staging.yml'
  workflow_dispatch: # Allow manual trigger

env:
  VPS_HOST: ${{ secrets.VPS_HOST }}
  VPS_USER: ${{ secrets.VPS_USER }}
  VPS_PATH_STAGING: /root/staging-backend
  DEPLOY_TIMEOUT: 600
  HEALTH_CHECK_URL: http://${{ secrets.VPS_HOST }}:3002/health

jobs:
  # ============================================
  # TEST JOB - Run tests before deployment
  # ============================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: deploy-backend/package-lock.json

      - name: Install dependencies
        working-directory: deploy-backend
        run: npm ci

      - name: Run linting
        working-directory: deploy-backend
        run: npm run lint || echo "::warning::Linting issues found"

      - name: Run type check
        working-directory: deploy-backend
        run: npx tsc --noEmit || echo "::warning::Type check issues found"

      - name: Run tests
        working-directory: deploy-backend
        run: npm run test -- --coverage --passWithNoTests
        env:
          NODE_ENV: test

      - name: Upload coverage report
        uses: codecov/codecov-action@v3
        with:
          directory: deploy-backend/coverage
          fail_ci_if_error: false
        continue-on-error: true

  # ============================================
  # DEPLOY JOB - Deploy to staging
  # ============================================
  deploy:
    name: Deploy to Staging VPS
    runs-on: ubuntu-latest
    needs: test
    timeout-minutes: 15

    steps:
      # ============================================
      # 1. CHECKOUT CODE
      # ============================================
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      # ============================================
      # 2. SETUP SSH
      # ============================================
      - name: Setup SSH key
        run: |
          echo "::group::Configure SSH"
          mkdir -p ~/.ssh

          # Handle both base64-encoded and raw SSH keys
          if echo "${{ secrets.VPS_SSH_KEY }}" | grep -q "BEGIN OPENSSH PRIVATE KEY"; then
            echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          else
            echo "${{ secrets.VPS_SSH_KEY }}" | base64 -d > ~/.ssh/deploy_key
          fi

          chmod 600 ~/.ssh/deploy_key

          # Add VPS to known_hosts
          ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts

          # Verify key format
          if ! ssh-keygen -l -f ~/.ssh/deploy_key > /dev/null 2>&1; then
            echo "::error::Invalid SSH key format."
            exit 1
          fi

          # Test SSH connection
          ssh -i ~/.ssh/deploy_key -o ConnectTimeout=10 ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo 'SSH connection successful'"
          echo "::endgroup::"

      # ============================================
      # 3. PRE-DEPLOYMENT CHECKS
      # ============================================
      - name: Pre-deployment checks
        run: |
          echo "::group::Pre-deployment checks"

          # Verify SSH connectivity
          echo "✓ Verifying SSH connectivity..."
          ssh -i ~/.ssh/deploy_key -o ConnectTimeout=10 ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo 'SSH verified' && uptime"

          # Check disk space
          echo "✓ Checking VPS disk space..."
          DISK_USAGE=$(ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "df -h /root | tail -1 | awk '{print \$5}' | sed 's/%//'")
          echo "Disk usage: ${DISK_USAGE}%"

          if [ "$DISK_USAGE" -gt 90 ]; then
            echo "::error::Disk usage is above 90%"
            exit 1
          fi

          # Check Docker
          echo "✓ Checking Docker status..."
          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "docker info > /dev/null 2>&1"

          # Create staging directory if not exists
          echo "✓ Ensuring staging directory exists..."
          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "mkdir -p ${{ env.VPS_PATH_STAGING }}"

          echo "::endgroup::"

      # ============================================
      # 4. SYNC FILES TO STAGING
      # ============================================
      - name: Sync files to Staging VPS
        run: |
          echo "::group::Sync files via rsync"

          # Sync ONLY deploy-backend/ to VPS staging
          rsync -avz --delete \
            --exclude 'node_modules' \
            --exclude 'dist' \
            --exclude '.env' \
            --exclude '.env.staging' \
            --exclude 'coverage' \
            --exclude 'backups' \
            --exclude 'certbot' \
            -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            deploy-backend/ \
            ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.VPS_PATH_STAGING }}/

          echo "✓ Files synced successfully"
          echo "::endgroup::"

      # ============================================
      # 5. SETUP STAGING ENVIRONMENT
      # ============================================
      - name: Setup staging environment
        run: |
          echo "::group::Setup staging environment"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'SETUP_SCRIPT'
            set -e
            cd ${{ env.VPS_PATH_STAGING }}

            # Create .env.staging if not exists
            if [ ! -f .env ]; then
              echo "Creating staging environment file..."
              cat > .env << 'ENVFILE'
POSTGRES_USER=staging_user
POSTGRES_PASSWORD=StagingSecurePass2024!
POSTGRES_DB=staging_whatsapp_saas
DATABASE_URL=postgresql://staging_user:StagingSecurePass2024!@postgres-staging:5432/staging_whatsapp_saas?schema=public
REDIS_HOST=redis-staging
REDIS_PORT=6379
REDIS_PASSWORD=StagingRedisPass2024!
REDIS_URL=redis://:StagingRedisPass2024!@redis-staging:6379
JWT_SECRET=staging_jwt_secret_min_32_chars_development_2024
JWT_REFRESH_SECRET=staging_refresh_secret_min_32_chars_development_2024
NODE_ENV=staging
PORT=3001
FRONTEND_URL=http://localhost:3000
BASE_DOMAIN=localhost
WHATSAPP_API_VERSION=v21.0
WHATSAPP_WEBHOOK_VERIFY_TOKEN=staging_webhook_verify_token_2024
N8N_API_KEY=staging_n8n_api_key_min_32_characters
SUPER_ADMIN_EMAIL=admin@staging.local
SUPER_ADMIN_PASSWORD=StagingAdmin123!
LOG_LEVEL=debug
ENVFILE
              echo "✓ Environment file created"
            else
              echo "✓ Environment file already exists"
            fi
          SETUP_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 6. BUILD DOCKER IMAGE
      # ============================================
      - name: Build Docker image
        run: |
          echo "::group::Build Docker image"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'BUILD_SCRIPT'
            set -e
            cd ${{ env.VPS_PATH_STAGING }}

            echo "Building staging backend Docker image..."
            docker compose -f docker-compose.staging.yml build backend-staging

            echo "✓ Docker image built successfully"
          BUILD_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 7. START STAGING CONTAINERS
      # ============================================
      - name: Start staging containers
        run: |
          echo "::group::Start staging containers"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'START_SCRIPT'
            set -e
            cd ${{ env.VPS_PATH_STAGING }}

            echo "Starting staging containers..."
            docker compose -f docker-compose.staging.yml up -d

            echo "✓ Staging containers started"

            # Wait for backend to be healthy
            echo "Waiting for staging backend to be healthy..."
            timeout 90 bash -c 'until docker inspect --format="{{.State.Health.Status}}" staging-backend 2>/dev/null | grep -q "healthy"; do echo "Waiting..."; sleep 5; done' || {
              echo "::warning::Container health check timeout"
            }

            # Show container status
            echo ""
            echo "Container status:"
            docker compose -f docker-compose.staging.yml ps
          START_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 8. RUN DATABASE MIGRATIONS
      # ============================================
      - name: Run database migrations
        run: |
          echo "::group::Run database migrations"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'MIGRATE_SCRIPT'
            set -e
            cd ${{ env.VPS_PATH_STAGING }}

            # Wait for postgres to be ready
            echo "Waiting for PostgreSQL..."
            timeout 30 bash -c 'until docker exec staging-postgres pg_isready -U staging_user 2>/dev/null; do echo "Waiting..."; sleep 2; done' || true

            # Run migrations
            echo "Running Prisma migrations..."
            docker compose -f docker-compose.staging.yml exec -T backend-staging npx prisma migrate deploy || {
              echo "::warning::Migration may have failed, checking logs..."
              docker compose -f docker-compose.staging.yml logs --tail=20 backend-staging
            }

            echo "✓ Migrations completed"
          MIGRATE_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 9. HEALTH CHECK
      # ============================================
      - name: Health check
        run: |
          echo "::group::Health check"

          MAX_RETRIES=20
          RETRY_INTERVAL=5

          echo "Waiting for staging application to be healthy..."
          echo "Health check URL: http://${{ env.VPS_HOST }}:3002/health"

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES..."

            RESPONSE=$(ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "curl -s -o /dev/null -w '%{http_code}' http://localhost:3002/health" || echo "000")

            if [ "$RESPONSE" = "200" ]; then
              echo "✓ Staging application is healthy!"

              # Get detailed health info
              echo ""
              echo "Health details:"
              ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "curl -s http://localhost:3002/health | jq '.' || curl -s http://localhost:3002/health"

              exit 0
            fi

            if [ $i -lt $MAX_RETRIES ]; then
              echo "Not healthy yet (status: $RESPONSE), waiting ${RETRY_INTERVAL}s..."
              sleep $RETRY_INTERVAL
            fi
          done

          echo "::error::Health check failed after $MAX_RETRIES attempts"

          # Show container logs for debugging
          echo ""
          echo "Backend logs (last 50 lines):"
          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} \
            "cd ${{ env.VPS_PATH_STAGING }} && docker compose -f docker-compose.staging.yml logs --tail=50 backend-staging"

          exit 1

          echo "::endgroup::"

      # ============================================
      # 10. RUN SMOKE TESTS
      # ============================================
      - name: Run smoke tests
        run: |
          echo "::group::Smoke tests"

          ssh -i ~/.ssh/deploy_key ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'SMOKE_SCRIPT'
            echo "Running smoke tests on staging..."

            # Test health endpoint
            echo "1. Testing /health endpoint..."
            curl -s http://localhost:3002/health | jq -e '.api == "ok"' || exit 1
            echo "   ✓ Health endpoint OK"

            # Test auth endpoint exists
            echo "2. Testing /auth/login endpoint exists..."
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST http://localhost:3002/auth/login -H "Content-Type: application/json" -d '{}')
            if [ "$STATUS" = "400" ] || [ "$STATUS" = "401" ]; then
              echo "   ✓ Auth endpoint responding (status: $STATUS)"
            else
              echo "   ✗ Auth endpoint unexpected status: $STATUS"
              exit 1
            fi

            echo ""
            echo "✓ All smoke tests passed!"
          SMOKE_SCRIPT

          echo "::endgroup::"

      # ============================================
      # 11. DEPLOYMENT SUMMARY
      # ============================================
      - name: Deployment summary
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✓ Staging deployment successful!"
            echo ""
            echo "Staging Environment:"
            echo "  - API: http://${{ env.VPS_HOST }}:3002"
            echo "  - Health: http://${{ env.VPS_HOST }}:3002/health"
            echo "  - Database: PostgreSQL on port 5433"
            echo ""
            echo "Next steps:"
            echo "  1. Test your changes on staging"
            echo "  2. When ready, merge develop -> master for production"
          else
            echo "✗ Staging deployment failed!"
            echo "Check logs above for details"
          fi

      # ============================================
      # 12. CLEANUP
      # ============================================
      - name: Cleanup SSH keys
        if: always()
        run: rm -f ~/.ssh/deploy_key
